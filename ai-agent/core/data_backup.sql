PRAGMA foreign_keys=OFF;
BEGIN TRANSACTION;
CREATE TABLE scans (
	id INTEGER NOT NULL, 
	project_name VARCHAR, 
	commit_sha VARCHAR, 
	timestamp DATETIME, 
	PRIMARY KEY (id)
);
INSERT INTO scans VALUES(1,'AnaaaKareem/devsecops-test','d777e7d2c76c9a5e8940bd9dfa43418715a0d7cb','2025-12-27 08:28:26.172149');
INSERT INTO scans VALUES(2,'AnaaaKareem/devsecops-test','c749891f06b4e37d0664aef485f118c2142854a9','2025-12-27 08:59:50.595223');
INSERT INTO scans VALUES(3,'AnaaaKareem/devsecops-test','5b066a35e249c27697fba08fdd2aac5f6f16bf5e','2025-12-27 09:12:13.417628');
INSERT INTO scans VALUES(4,'AnaaaKareem/devsecops-test','c555433cf960d4d2f36d2e97a8069ca92950ca6a','2025-12-27 09:31:06.638573');
INSERT INTO scans VALUES(5,'test/live-demo','HEAD','2025-12-27 10:03:00.434135');
INSERT INTO scans VALUES(6,'AnaaaKareem/devsecops-test','c555433cf960d4d2f36d2e97a8069ca92950ca6a','2025-12-27 10:09:17.133993');
INSERT INTO scans VALUES(7,'AnaaaKareem/devsecops-test','4aba842bdedf51457a88ae68960e5e44f0b5aa6a','2025-12-27 10:38:14.444877');
CREATE TABLE findings (
	id INTEGER NOT NULL, 
	scan_id INTEGER, 
	triage_decision VARCHAR, 
	sandbox_logs TEXT, 
	tool VARCHAR, 
	rule_id VARCHAR, 
	file VARCHAR, 
	line INTEGER, 
	message TEXT, 
	snippet TEXT, 
	ai_verdict VARCHAR, 
	ai_confidence FLOAT, 
	ai_reasoning TEXT, 
	risk_score FLOAT, 
	severity VARCHAR, 
	remediation_patch TEXT, 
	red_team_success BOOLEAN, 
	red_team_output TEXT, 
	pr_url VARCHAR, 
	pr_error VARCHAR, 
	PRIMARY KEY (id), 
	FOREIGN KEY(scan_id) REFERENCES scans (id)
);
INSERT INTO findings VALUES(1,1,'RV',unistr('\u000a--- RED_TEAM_POC (SUCCESS: False) ---\u000a  File "/app/poc_exploit.py", line 1\u000a    ```python\u000a    ^\u000aSyntaxError: invalid syntax\u000a\u000a\u000a--- SANITY_CHECK (SUCCESS: True) ---\u000aPatch looks valid.\u000a'),'Semgrep OSS','python.lang.security.audit.formatted-sql-query.formatted-sql-query','not_secure.py',24,'Detected possible formatted SQL query. Use parameterized queries instead.',unistr('def get_user(user_id: str):\u000a    conn = sqlite3.connect(''users.db'')\u000a    cursor = conn.cursor()\u000a    # DANGEROUS: Direct string formatting into SQL\u000a    query = f"SELECT * FROM users WHERE id = ''{user_id}''"\u000a    cursor.execute(query)\u000a    return cursor.fetchone()\u000a\u000a@app.get("/ping")\u000adef ping_host(host: str):\u000a'),'TP',NULL,NULL,5.0,'Medium',unistr('import sqlite3\u000afrom fastapi import FastAPI\u000a\u000aapp = FastAPI()\u000a\u000a\u000adef get_user(user_id: str):\u000a    """\u000a    Retrieve a user record from the SQLite database using a parameterized query.\u000a    This prevents SQL injection by avoiding direct string interpolation of `user_id`.\u000a    """\u000a    # Use a context manager to ensure the connection is closed automatically\u000a    with sqlite3.connect("users.db") as conn:\u000a        cursor = conn.cursor()\u000a        # Parameterized query – the placeholder ''?'' will be safely replaced\u000a        query = "SELECT * FROM users WHERE id = ?"\u000a        cursor.execute(query, (user_id,))\u000a        return cursor.fetchone()\u000a\u000a\u000a@app.get("/ping")\u000adef ping_host(host: str):\u000a    """\u000a    Simple health‑check endpoint that echoes back the supplied host.\u000a    """\u000a    # In a real application you might perform an actual network check here\u000a    return {"host": host}'),0,unistr('  File "/app/poc_exploit.py", line 1\u000a    ```python\u000a    ^\u000aSyntaxError: invalid syntax\u000a'),'https://github.com/AnaaaKareem/devsecops-test/pull/27',NULL);
INSERT INTO findings VALUES(2,1,'RV',unistr('\u000a--- RED_TEAM_POC (SUCCESS: False) ---\u000a  File "/app/poc_exploit.py", line 1\u000a    ```python\u000a    ^\u000aSyntaxError: invalid syntax\u000a\u000a\u000a--- SANITY_CHECK (SUCCESS: True) ---\u000aPatch looks valid.\u000a'),'Semgrep OSS','python.sqlalchemy.security.sqlalchemy-execute-raw-query.sqlalchemy-execute-raw-query','not_secure.py',24,'Avoiding SQL string concatenation: untrusted input concatenated with raw SQL query can result in SQL Injection. In order to execute raw query safely, prepared statement should be used. SQLAlchemy provides TextualSQL to easily used prepared statement with named parameters. For complex SQL composition, use SQL Expression Language or Schema Definition Language. In most cases, SQLAlchemy ORM will be a better option.',unistr('def get_user(user_id: str):\u000a    conn = sqlite3.connect(''users.db'')\u000a    cursor = conn.cursor()\u000a    # DANGEROUS: Direct string formatting into SQL\u000a    query = f"SELECT * FROM users WHERE id = ''{user_id}''"\u000a    cursor.execute(query)\u000a    return cursor.fetchone()\u000a\u000a@app.get("/ping")\u000adef ping_host(host: str):\u000a'),'TP',NULL,NULL,8.0,'High',unistr('import sqlite3\u000afrom fastapi import FastAPI\u000a\u000aapp = FastAPI()\u000a\u000a\u000adef get_user(user_id: str):\u000a    """\u000a    Retrieve a user record safely using a parameterized query to avoid SQL injection.\u000a    """\u000a    # Use a context manager so the connection is closed automatically\u000a    with sqlite3.connect("users.db") as conn:\u000a        cursor = conn.cursor()\u000a        # Parameterized query – the ''?'' placeholder protects against injection\u000a        cursor.execute(\u000a            "SELECT * FROM users WHERE id = ?", (user_id,)\u000a        )\u000a        return cursor.fetchone()\u000a\u000a\u000a@app.get("/ping")\u000aasync def ping_host(host: str):\u000a    """\u000a    Simple health‑check endpoint that echoes back the host name.\u000a    """\u000a    # In a real application you might perform an actual connectivity check here\u000a    return {"host": host, "status": "ok"}'),0,unistr('  File "/app/poc_exploit.py", line 1\u000a    ```python\u000a    ^\u000aSyntaxError: invalid syntax\u000a'),'https://github.com/AnaaaKareem/devsecops-test/pull/27',NULL);
INSERT INTO findings VALUES(3,1,'RV',unistr('\u000a--- RED_TEAM_POC (SUCCESS: False) ---\u000a  File "/app/poc_exploit.py", line 1\u000a    ```python\u000a    ^\u000aSyntaxError: invalid syntax\u000a\u000a\u000a--- SANITY_CHECK (SUCCESS: True) ---\u000aPatch looks valid.\u000a'),'Semgrep OSS','python.lang.security.audit.subprocess-shell-true.subprocess-shell-true','not_secure.py',31,'Found ''subprocess'' function ''check_output'' with ''shell=True''. This is dangerous because this call will spawn the command using a shell process. Doing so propagates current shell settings and variables, which makes it much easier for a malicious actor to execute commands. Use ''shell=False'' instead.',unistr('\u000a@app.get("/ping")\u000adef ping_host(host: str):\u000a    # DANGEROUS: User input passed directly to shell\u000a    # An attacker could send: "8.8.8.8; rm -rf /"\u000a    result = subprocess.check_output(f"ping -c 1 {host}", shell=True)\u000a    return {"output": result.decode()}\u000a\u000aimport pickle\u000a@app.post("/load_profile")\u000a'),'TP',NULL,NULL,5.0,'Medium',unistr('from fastapi import FastAPI\u000aimport subprocess\u000a\u000aapp = FastAPI()\u000a\u000a\u000a@app.get("/ping")\u000adef ping_host(host: str):\u000a    """\u000a    Ping the supplied host using a safe, non‑shell invocation of `ping`.\u000a\u000a    Parameters\u000a    ----------\u000a    host : str\u000a        The hostname or IP address to ping.\u000a\u000a    Returns\u000a    -------\u000a    dict\u000a        JSON containing either the command output or an error message.\u000a    """\u000a    try:\u000a        # Use a list of arguments so that no shell is spawned.\u000a        result = subprocess.check_output(\u000a            ["ping", "-c", "1", host],\u000a            stderr=subprocess.STDOUT,\u000a        )\u000a        return {"output": result.decode()}\u000a    except subprocess.CalledProcessError as exc:\u000a        # Return the error output if ping fails (e.g., unreachable host)\u000a        return {"error": exc.output.decode()}\u000a\u000a\u000a# --------------------------------------------------------------------------- #\u000a# Any additional routes can be added below.  The `import pickle` line from the\u000a# original snippet was removed because it was unused and could introduce\u000a# unnecessary risk.'),0,unistr('  File "/app/poc_exploit.py", line 1\u000a    ```python\u000a    ^\u000aSyntaxError: invalid syntax\u000a'),'https://github.com/AnaaaKareem/devsecops-test/pull/27',NULL);
INSERT INTO findings VALUES(4,1,'RV',unistr('\u000a--- RED_TEAM_POC (SUCCESS: False) ---\u000a  File "/app/poc_exploit.py", line 1\u000a    ```python\u000a    ^\u000aSyntaxError: invalid syntax\u000a\u000a\u000a--- SANITY_CHECK (SUCCESS: True) ---\u000aPatch looks valid.\u000a'),'Semgrep OSS','python.django.security.audit.avoid-insecure-deserialization.avoid-insecure-deserialization','not_secure.py',39,'Avoid using insecure deserialization library, backed by `pickle`, `_pickle`, `cpickle`, `dill`, `shelve`, or `yaml`, which are known to lead to remote code execution vulnerabilities.',unistr('import pickle\u000a@app.post("/load_profile")\u000aasync def load_profile(request: Request):\u000a    data = await request.body()\u000a    # DANGEROUS: Unpickling untrusted data leads to RCE\u000a    profile = pickle.loads(data)\u000a    return {"profile": "loaded"}\u000a\u000adef run_user_command(user_input):\u000a    return subprocess.check_output(user_input, shell=True)\u000a'),'TP',NULL,NULL,8.0,'High',unistr('import json\u000aimport shlex\u000aimport subprocess\u000a\u000afrom fastapi import FastAPI, Request\u000a\u000aapp = FastAPI()\u000a\u000a\u000a@app.post("/load_profile")\u000aasync def load_profile(request: Request):\u000a    """\u000a    Safely load a user profile from JSON data.\u000a    The request body must be valid JSON; no pickle or other unsafe\u000a    deserialization is performed.  This prevents remote code execution\u000a    via malicious payloads.\u000a    """\u000a    # Parse the incoming request body as JSON\u000a    try:\u000a        data = await request.json()\u000a    except json.JSONDecodeError:\u000a        return {"error": "Invalid JSON"}\u000a\u000a    # In a real application you would validate and process `data` here.\u000a    # For demonstration we simply acknowledge receipt.\u000a    profile = data  # placeholder for actual processing logic\u000a\u000a    return {"profile": "loaded"}\u000a\u000a\u000adef run_user_command(user_input: str) -> bytes:\u000a    """\u000a    Execute a user‑supplied command safely.\u000a\u000a    The function splits the input into arguments and runs it without\u000a    invoking the shell, which mitigates injection attacks.  If you need to\u000a    execute arbitrary shell commands, consider using a whitelist or other\u000a    stricter controls instead of this helper.\u000a    """\u000a    # Split the command string into a list of arguments safely\u000a    args = shlex.split(user_input)\u000a\u000a    # Execute the command without invoking the shell\u000a    return subprocess.check_output(args, shell=False)'),0,unistr('  File "/app/poc_exploit.py", line 1\u000a    ```python\u000a    ^\u000aSyntaxError: invalid syntax\u000a'),'https://github.com/AnaaaKareem/devsecops-test/pull/27',NULL);
INSERT INTO findings VALUES(5,1,'RV',unistr('\u000a--- RED_TEAM_POC (SUCCESS: False) ---\u000a  File "/app/poc_exploit.py", line 1\u000a    ```python\u000a    ^\u000aSyntaxError: invalid syntax\u000a\u000a\u000a--- SANITY_CHECK (SUCCESS: True) ---\u000aPatch looks valid.\u000a'),'Semgrep OSS','python.lang.security.deserialization.pickle.avoid-pickle','not_secure.py',39,'Avoid using `pickle`, which is known to lead to code execution vulnerabilities. When unpickling, the serialized data could be manipulated to run arbitrary code. Instead, consider serializing the relevant data as JSON or a similar text-based serialization format.',unistr('import pickle\u000a@app.post("/load_profile")\u000aasync def load_profile(request: Request):\u000a    data = await request.body()\u000a    # DANGEROUS: Unpickling untrusted data leads to RCE\u000a    profile = pickle.loads(data)\u000a    return {"profile": "loaded"}\u000a\u000adef run_user_command(user_input):\u000a    return subprocess.check_output(user_input, shell=True)\u000a'),'TP',NULL,NULL,5.0,'Medium',unistr('import json\u000aimport shlex\u000afrom fastapi import FastAPI, Request\u000aimport subprocess\u000a\u000aapp = FastAPI()\u000a\u000a\u000a@app.post("/load_profile")\u000aasync def load_profile(request: Request):\u000a    # Read the raw request body (bytes)\u000a    body_bytes = await request.body()\u000a    try:\u000a        # Decode bytes to a UTF‑8 string and parse JSON\u000a        data_str = body_bytes.decode("utf-8")\u000a        profile_data = json.loads(data_str)\u000a    except (UnicodeDecodeError, json.JSONDecodeError):\u000a        return {"error": "Invalid JSON payload"}\u000a\u000a    # Here you can process the profile_data as needed.\u000a    # For demonstration we simply echo it back.\u000a    return {"profile": profile_data}\u000a\u000a\u000adef run_user_command(user_input: str) -> str:\u000a    """\u000a    Execute a user‑supplied command safely.\u000a\u000a    Instead of using `shell=True`, which would allow arbitrary shell\u000a    injection, we split the input into a list of arguments and pass that\u000a    directly to subprocess.  This prevents the shell from interpreting\u000a    special characters.\u000a    """\u000a    # Split the string into arguments in a shell‑like way but without invoking a shell\u000a    args = shlex.split(user_input)\u000a\u000a    try:\u000a        output_bytes = subprocess.check_output(\u000a            args,\u000a            stderr=subprocess.STDOUT,   # capture stderr as well\u000a        )\u000a    except subprocess.CalledProcessError as e:\u000a        return e.output.decode()\u000a\u000a    return output_bytes.decode()'),0,unistr('  File "/app/poc_exploit.py", line 1\u000a    ```python\u000a    ^\u000aSyntaxError: invalid syntax\u000a'),'https://github.com/AnaaaKareem/devsecops-test/pull/27',NULL);
INSERT INTO findings VALUES(6,1,'RV',unistr('\u000a--- RED_TEAM_POC (SUCCESS: False) ---\u000a  File "/app/poc_exploit.py", line 1\u000a    ```python\u000a    ^\u000aSyntaxError: invalid syntax\u000a\u000a\u000a--- SANITY_CHECK (SUCCESS: True) ---\u000aPatch looks valid.\u000a'),'Semgrep OSS','python.lang.security.audit.subprocess-shell-true.subprocess-shell-true','not_secure.py',43,'Found ''subprocess'' function ''check_output'' with ''shell=True''. This is dangerous because this call will spawn the command using a shell process. Doing so propagates current shell settings and variables, which makes it much easier for a malicious actor to execute commands. Use ''shell=False'' instead.',unistr('    # DANGEROUS: Unpickling untrusted data leads to RCE\u000a    profile = pickle.loads(data)\u000a    return {"profile": "loaded"}\u000a\u000adef run_user_command(user_input):\u000a    return subprocess.check_output(user_input, shell=True)\u000a\u000adef load_user_data(serialized_data):\u000a    return pickle.loads(serialized_data)\u000a\u000a'),'TP',NULL,NULL,5.0,'Medium',unistr('import json\u000aimport subprocess\u000aimport shlex\u000a\u000a# --------------------------------------------------------------------------- #\u000a# 1️⃣  Safe deserialization – never use pickle on untrusted input.\u000a#    We replace the insecure `pickle.loads` with JSON parsing, which only\u000a#    constructs basic Python data structures (dicts, lists, strings,\u000a#    numbers, booleans, and None).  This eliminates the risk of remote code\u000a#    execution that can arise from arbitrary pickle payloads.\u000a#\u000a# 2️⃣  Safe subprocess invocation – avoid `shell=True`.  We accept either a\u000a#     string or an iterable of arguments.  If a string is supplied we split it\u000a#     safely with `shlex.split`; otherwise the list/tuple is used directly.\u000a#     The call is made with `shell=False`, so no shell is spawned and no\u000a#     shell‑specific environment variables are inherited, preventing command\u000a#     injection attacks.\u000a#\u000a# --------------------------------------------------------------------------- #\u000a\u000adef load_user_profile(data: str) -> dict:\u000a    """\u000a    Safely deserialize user profile data from a JSON string.\u000a\u000a    Parameters\u000a    ----------\u000a    data : str\u000a        A JSON-encoded string representing the user''s profile.\u000a\u000a    Returns\u000a    -------\u000a    dict\u000a        The parsed profile dictionary, wrapped in a response structure.\u000a    """\u000a    try:\u000a        profile = json.loads(data)\u000a    except json.JSONDecodeError as exc:\u000a        raise ValueError("Invalid user data") from exc\u000a\u000a    return {"profile": "loaded", "data": profile}\u000a\u000a\u000adef run_user_command(user_input):\u000a    """\u000a    Execute a user‑supplied command safely.\u000a\u000a    Parameters\u000a    ----------\u000a    user_input : str | list[str] | tuple[str]\u000a        The command to execute.  If a string is given it will be split into\u000a        arguments using `shlex.split`.  If an iterable of strings is supplied,\u000a        it is used directly as the argument list.\u000a\u000a    Returns\u000a    -------\u000a    str\u000a        The stdout output from the executed command.\u000a    """\u000a    # Normalise to a list of arguments\u000a    if isinstance(user_input, str):\u000a        args = shlex.split(user_input)\u000a    elif isinstance(user_input, (list, tuple)):\u000a        args = list(user_input)\u000a    else:\u000a        raise TypeError("Command must be a string or list/tuple of strings")\u000a\u000a    # Execute without spawning a shell\u000a    try:\u000a        output = subprocess.check_output(args, shell=False, text=True)\u000a    except subprocess.SubprocessError as exc:\u000a        raise RuntimeError(f"Command failed: {exc}") from exc\u000a\u000a    return output\u000a\u000a\u000adef load_user_data(serialized_data: str) -> dict:\u000a    """\u000a    Wrapper that keeps the original API surface but uses safe JSON loading.\u000a    """\u000a    return load_user_profile(serialized_data)'),0,unistr('  File "/app/poc_exploit.py", line 1\u000a    ```python\u000a    ^\u000aSyntaxError: invalid syntax\u000a'),'https://github.com/AnaaaKareem/devsecops-test/pull/27',NULL);
INSERT INTO findings VALUES(7,1,'RV',unistr('\u000a--- RED_TEAM_POC (SUCCESS: True) ---\u000a=== Command Injection Demo ===\u000aHello from injected command\u000aInjected again!\u000a\u000a\u000a=== Pickle Arbitrary Code Execution Demo ===\u000aFile content: Arbitrary code executed by pickle\u000a\u000a\u000a\u000a--- SANITY_CHECK (SUCCESS: True) ---\u000aPatch looks valid.\u000a'),'Semgrep OSS','python.lang.security.deserialization.pickle.avoid-pickle','not_secure.py',46,'Avoid using `pickle`, which is known to lead to code execution vulnerabilities. When unpickling, the serialized data could be manipulated to run arbitrary code. Instead, consider serializing the relevant data as JSON or a similar text-based serialization format.',unistr('\u000adef run_user_command(user_input):\u000a    return subprocess.check_output(user_input, shell=True)\u000a\u000adef load_user_data(serialized_data):\u000a    return pickle.loads(serialized_data)\u000a\u000a"""\u000aDOCKERFILE HINT (for Checkov testing):\u000aFROM python:3.8-slim\u000a'),'TP',NULL,NULL,10.0,'Critical',unistr('import subprocess\u000aimport json\u000a\u000adef run_user_command(user_input):\u000a    """Execute a shell command and return its output."""\u000a    return subprocess.check_output(user_input, shell=True)\u000a\u000adef load_user_data(serialized_data):\u000a    """\u000a    Load user data from a JSON-encoded string or bytes object.\u000a    \u000a    This replaces the insecure pickle-based deserialization. The function accepts\u000a    either a JSON string or a bytes/bytearray containing UTF‑8 encoded JSON,\u000a    and returns the corresponding Python object (dict, list, etc.).\u000a    """\u000a    # Ensure we have a text string to feed into json.loads()\u000a    if isinstance(serialized_data, (bytes, bytearray)):\u000a        data_str = serialized_data.decode("utf-8")\u000a    else:\u000a        data_str = str(serialized_data)\u000a    \u000a    return json.loads(data_str)'),1,unistr('=== Command Injection Demo ===\u000aHello from injected command\u000aInjected again!\u000a\u000a\u000a=== Pickle Arbitrary Code Execution Demo ===\u000aFile content: Arbitrary code executed by pickle\u000a\u000a'),'https://github.com/AnaaaKareem/devsecops-test/pull/27',NULL);
INSERT INTO findings VALUES(8,1,'RV',unistr('\u000a--- RED_TEAM_POC (SUCCESS: False) ---\u000a  File "/app/poc_exploit.py", line 1\u000a    ```python\u000a    ^\u000aSyntaxError: invalid syntax\u000a\u000a\u000a--- SANITY_CHECK (SUCCESS: True) ---\u000aPatch looks valid.\u000a'),'Trivy','stripe-secret-token','not_secure.py',12,unistr('Artifact: not_secure.py\u000aType: \u000aSecret Stripe Secret Key\u000aSeverity: CRITICAL\u000aMatch: STRIPE_API_KEY = "********************************"'),unistr('from cryptography.fernet import Fernet\u000a\u000aapp = FastAPI()\u000a\u000aAWS_SECRET_KEY = "AKIAIMNO78987SAMPLEKEY/bXU8JEIKN89098"\u000aSTRIPE_API_KEY = "sk_test_4eC39HqLyjWDarjtT1zdp7dc"\u000aDEBUG_PASSWORD = "admin_password_123!"\u000a\u000aWEAK_KEY = b''PR6H93e48950S3Kcy04R0S4R85E6p287'' # Hardcoded\u000acipher = Fernet(base64.urlsafe_b64encode(b"static_key_12345")) \u000a'),'TP',NULL,NULL,5.0,'Medium',unistr('import os\u000afrom fastapi import FastAPI\u000afrom cryptography.fernet import Fernet\u000aimport base64\u000a\u000a# ------------------------------------------------------------------\u000a# Configuration – secrets must be supplied via environment variables.\u000a# ------------------------------------------------------------------\u000aAWS_SECRET_KEY: str | None = os.getenv("AWS_SECRET_KEY")\u000aSTRIPE_API_KEY: str | None = os.getenv("STRIPE_API_KEY")\u000a\u000aif not AWS_SECRET_KEY or not STRIPE_API_KEY:\u000a    raise RuntimeError(\u000a        "Missing required secret environment variables. "\u000a        "Set AWS_SECRET_KEY and STRIPE_API_KEY before starting the app."\u000a    )\u000a\u000a# ------------------------------------------------------------------\u000a# FastAPI application instance\u000a# ------------------------------------------------------------------\u000aapp = FastAPI()\u000a\u000a# ------------------------------------------------------------------\u000a# Example of a secure Fernet cipher – key is generated from a cryptographically strong source.\u000a# ------------------------------------------------------------------\u000afernet_key_bytes: bytes = os.urandom(32)          # 256‑bit random key\u000afernet_key_b64: bytes = base64.urlsafe_b64encode(fernet_key_bytes)\u000acipher: Fernet = Fernet(fernet_key_b64)\u000a\u000a# ------------------------------------------------------------------\u000a# Helper functions (optional – show how to use the cipher)\u000a# ------------------------------------------------------------------\u000adef encrypt_data(data: str) -> bytes:\u000a    """Encrypt a UTF‑8 string and return the ciphertext."""\u000a    return cipher.encrypt(data.encode("utf-8"))\u000a\u000adef decrypt_data(token: bytes) -> str:\u000a    """Decrypt a Fernet token and return the original UTF‑8 string."""\u000a    return cipher.decrypt(token).decode("utf-8")\u000a\u000a# ------------------------------------------------------------------\u000a# Example endpoint (illustrative – not exposing secrets)\u000a# ------------------------------------------------------------------\u000a@app.get("/health")\u000aasync def health_check() -> dict:\u000a    """Simple health‑check endpoint."""\u000a    return {"status": "ok"}'),0,unistr('  File "/app/poc_exploit.py", line 1\u000a    ```python\u000a    ^\u000aSyntaxError: invalid syntax\u000a'),'https://github.com/AnaaaKareem/devsecops-test/pull/27',NULL);
INSERT INTO findings VALUES(9,1,'RV',unistr('\u000a--- RED_TEAM_POC (SUCCESS: False) ---\u000a  File "/app/poc_exploit.py", line 1\u000a    ```python\u000a    ^\u000aSyntaxError: invalid syntax\u000a\u000a\u000a--- SANITY_CHECK (SUCCESS: True) ---\u000aPatch looks valid.\u000a'),'Gitleaks','stripe-access-token','not_secure.py',12,'Found a Stripe Access Token, posing a risk to payment processing services and sensitive financial data.',unistr('from cryptography.fernet import Fernet\u000a\u000aapp = FastAPI()\u000a\u000aAWS_SECRET_KEY = "AKIAIMNO78987SAMPLEKEY/bXU8JEIKN89098"\u000aSTRIPE_API_KEY = "sk_test_4eC39HqLyjWDarjtT1zdp7dc"\u000aDEBUG_PASSWORD = "admin_password_123!"\u000a\u000aWEAK_KEY = b''PR6H93e48950S3Kcy04R0S4R85E6p287'' # Hardcoded\u000acipher = Fernet(base64.urlsafe_b64encode(b"static_key_12345")) \u000a'),'TP',NULL,NULL,5.0,'Medium',unistr('import os\u000afrom fastapi import FastAPI\u000afrom cryptography.fernet import Fernet\u000a\u000a# --------------------------------------------------------------------------- #\u000a#  Configuration – load secrets from environment variables (never hard‑code them)\u000a# --------------------------------------------------------------------------- #\u000a\u000aAWS_SECRET_KEY = os.getenv("AWS_SECRET_KEY")\u000aSTRIPE_API_KEY = os.getenv("STRIPE_API_KEY")\u000a\u000aif not AWS_SECRET_KEY or not STRIPE_API_KEY:\u000a    raise RuntimeError(\u000a        "Missing required environment variables: "\u000a        "''AWS_SECRET_KEY'' and/or ''STRIPE_API_KEY''"\u000a    )\u000a\u000a# --------------------------------------------------------------------------- #\u000a#  Secure Fernet key – either supplied via env var or generated on first run\u000a# --------------------------------------------------------------------------- #\u000a\u000aFERNET_KEY = os.getenv("FERNET_KEY")\u000a\u000aif FERNET_KEY is None:\u000a    # Generate a new 32‑byte urlsafe base64‑encoded key.\u000a    # In production you would store this securely (e.g. in AWS KMS, Vault, etc.)\u000a    FERNET_KEY = Fernet.generate_key()\u000a\u000a# Ensure the key is bytes – Fernet expects a bytes object\u000aif isinstance(FERNET_KEY, str):\u000a    FERNET_KEY = FERNET_KEY.encode()\u000a\u000acipher = Fernet(FERNET_KEY)\u000a\u000a# --------------------------------------------------------------------------- #\u000a#  FastAPI application instance\u000a# --------------------------------------------------------------------------- #\u000a\u000aapp = FastAPI()'),0,unistr('  File "/app/poc_exploit.py", line 1\u000a    ```python\u000a    ^\u000aSyntaxError: invalid syntax\u000a'),'https://github.com/AnaaaKareem/devsecops-test/pull/27',NULL);
INSERT INTO findings VALUES(10,1,'RV',unistr('\u000a--- RED_TEAM_POC (SUCCESS: True) ---\u000a\u000a\u000a--- SANITY_CHECK (SUCCESS: True) ---\u000aPatch looks valid.\u000a'),'Gitleaks','stripe-access-token','not_secure.py',8,'Found a Stripe Access Token, posing a risk to payment processing services and sensitive financial data.',unistr('import subprocess\u000aimport base64\u000aimport pickle\u000afrom fastapi import FastAPI, Request\u000afrom cryptography.fernet import Fernet\u000a\u000aapp = FastAPI()\u000a\u000aAWS_SECRET_KEY = "AKIAIMNO78987SAMPLEKEY/bXU8JEIKN89098"\u000aSTRIPE_API_KEY = "sk_test_4eC39HqLyjWDarjtT1zdp7dc"\u000a'),'TP',NULL,NULL,10.0,'Critical',unistr('import os\u000a\u000afrom fastapi import FastAPI, Request\u000afrom cryptography.fernet import Fernet\u000a\u000aapp = FastAPI()\u000a\u000a# Load sensitive credentials from environment variables (never hard‑code them)\u000aAWS_SECRET_KEY: str | None = os.getenv("AWS_SECRET_KEY")\u000aSTRIPE_API_KEY: str | None = os.getenv("STRIPE_API_KEY")\u000a\u000a# If you need to use the keys, make sure they are present\u000aif not AWS_SECRET_KEY or not STRIPE_API_KEY:\u000a    raise RuntimeError(\u000a        "Missing required environment variables for AWS and Stripe credentials."\u000a    )\u000a\u000a# Example endpoint that demonstrates safe usage of the secrets\u000a@app.get("/payment")\u000aasync def payment_endpoint(request: Request):\u000a    # Here you would normally call the Stripe API using the provided key.\u000a    # For demonstration purposes, we simply return a success message.\u000a    return {"status": "success", "message": "Payment processed securely."}'),1,'','https://github.com/AnaaaKareem/devsecops-test/pull/27',NULL);
INSERT INTO findings VALUES(11,3,NULL,NULL,'Semgrep OSS','python.lang.security.audit.formatted-sql-query.formatted-sql-query','not_secure.py',24,'Detected possible formatted SQL query. Use parameterized queries instead.',unistr('def get_user(user_id: str):\u000a    conn = sqlite3.connect(''users.db'')\u000a    cursor = conn.cursor()\u000a    # DANGEROUS: Direct string formatting into SQL\u000a    query = f"SELECT * FROM users WHERE id = ''{user_id}''"\u000a    cursor.execute(query)\u000a    return cursor.fetchone()\u000a\u000a@app.get("/ping")\u000adef ping_host(host: str):\u000a'),NULL,NULL,NULL,NULL,NULL,NULL,0,NULL,NULL,NULL);
INSERT INTO findings VALUES(12,3,NULL,NULL,'Semgrep OSS','python.sqlalchemy.security.sqlalchemy-execute-raw-query.sqlalchemy-execute-raw-query','not_secure.py',24,'Avoiding SQL string concatenation: untrusted input concatenated with raw SQL query can result in SQL Injection. In order to execute raw query safely, prepared statement should be used. SQLAlchemy provides TextualSQL to easily used prepared statement with named parameters. For complex SQL composition, use SQL Expression Language or Schema Definition Language. In most cases, SQLAlchemy ORM will be a better option.',unistr('def get_user(user_id: str):\u000a    conn = sqlite3.connect(''users.db'')\u000a    cursor = conn.cursor()\u000a    # DANGEROUS: Direct string formatting into SQL\u000a    query = f"SELECT * FROM users WHERE id = ''{user_id}''"\u000a    cursor.execute(query)\u000a    return cursor.fetchone()\u000a\u000a@app.get("/ping")\u000adef ping_host(host: str):\u000a'),NULL,NULL,NULL,NULL,NULL,NULL,0,NULL,NULL,NULL);
INSERT INTO findings VALUES(13,3,NULL,NULL,'Semgrep OSS','python.lang.security.audit.subprocess-shell-true.subprocess-shell-true','not_secure.py',31,'Found ''subprocess'' function ''check_output'' with ''shell=True''. This is dangerous because this call will spawn the command using a shell process. Doing so propagates current shell settings and variables, which makes it much easier for a malicious actor to execute commands. Use ''shell=False'' instead.',unistr('\u000a@app.get("/ping")\u000adef ping_host(host: str):\u000a    # DANGEROUS: User input passed directly to shell\u000a    # An attacker could send: "8.8.8.8; rm -rf /"\u000a    result = subprocess.check_output(f"ping -c 1 {host}", shell=True)\u000a    return {"output": result.decode()}\u000a\u000aimport pickle\u000a@app.post("/load_profile")\u000a'),NULL,NULL,NULL,NULL,NULL,NULL,0,NULL,NULL,NULL);
INSERT INTO findings VALUES(14,3,NULL,NULL,'Semgrep OSS','python.django.security.audit.avoid-insecure-deserialization.avoid-insecure-deserialization','not_secure.py',39,'Avoid using insecure deserialization library, backed by `pickle`, `_pickle`, `cpickle`, `dill`, `shelve`, or `yaml`, which are known to lead to remote code execution vulnerabilities.',unistr('import pickle\u000a@app.post("/load_profile")\u000aasync def load_profile(request: Request):\u000a    data = await request.body()\u000a    # DANGEROUS: Unpickling untrusted data leads to RCE\u000a    profile = pickle.loads(data)\u000a    return {"profile": "loaded"}\u000a\u000adef run_user_command(user_input):\u000a    return subprocess.check_output(user_input, shell=True)\u000a'),NULL,NULL,NULL,NULL,NULL,NULL,0,NULL,NULL,NULL);
INSERT INTO findings VALUES(15,3,NULL,NULL,'Semgrep OSS','python.lang.security.deserialization.pickle.avoid-pickle','not_secure.py',39,'Avoid using `pickle`, which is known to lead to code execution vulnerabilities. When unpickling, the serialized data could be manipulated to run arbitrary code. Instead, consider serializing the relevant data as JSON or a similar text-based serialization format.',unistr('import pickle\u000a@app.post("/load_profile")\u000aasync def load_profile(request: Request):\u000a    data = await request.body()\u000a    # DANGEROUS: Unpickling untrusted data leads to RCE\u000a    profile = pickle.loads(data)\u000a    return {"profile": "loaded"}\u000a\u000adef run_user_command(user_input):\u000a    return subprocess.check_output(user_input, shell=True)\u000a'),NULL,NULL,NULL,NULL,NULL,NULL,0,NULL,NULL,NULL);
INSERT INTO findings VALUES(16,3,NULL,NULL,'Semgrep OSS','python.lang.security.audit.subprocess-shell-true.subprocess-shell-true','not_secure.py',43,'Found ''subprocess'' function ''check_output'' with ''shell=True''. This is dangerous because this call will spawn the command using a shell process. Doing so propagates current shell settings and variables, which makes it much easier for a malicious actor to execute commands. Use ''shell=False'' instead.',unistr('    # DANGEROUS: Unpickling untrusted data leads to RCE\u000a    profile = pickle.loads(data)\u000a    return {"profile": "loaded"}\u000a\u000adef run_user_command(user_input):\u000a    return subprocess.check_output(user_input, shell=True)\u000a\u000adef load_user_data(serialized_data):\u000a    return pickle.loads(serialized_data)\u000a\u000a'),NULL,NULL,NULL,NULL,NULL,NULL,0,NULL,NULL,NULL);
INSERT INTO findings VALUES(17,3,NULL,NULL,'Semgrep OSS','python.lang.security.deserialization.pickle.avoid-pickle','not_secure.py',46,'Avoid using `pickle`, which is known to lead to code execution vulnerabilities. When unpickling, the serialized data could be manipulated to run arbitrary code. Instead, consider serializing the relevant data as JSON or a similar text-based serialization format.',unistr('\u000adef run_user_command(user_input):\u000a    return subprocess.check_output(user_input, shell=True)\u000a\u000adef load_user_data(serialized_data):\u000a    return pickle.loads(serialized_data)\u000a\u000a"""\u000aDOCKERFILE HINT (for Checkov testing):\u000aFROM python:3.8-slim\u000a'),NULL,NULL,NULL,NULL,NULL,NULL,0,NULL,NULL,NULL);
INSERT INTO findings VALUES(18,3,NULL,NULL,'Trivy','stripe-secret-token','not_secure.py',12,unistr('Artifact: not_secure.py\u000aType: \u000aSecret Stripe Secret Key\u000aSeverity: CRITICAL\u000aMatch: STRIPE_API_KEY = "********************************"'),unistr('from cryptography.fernet import Fernet\u000a\u000aapp = FastAPI()\u000a\u000aAWS_SECRET_KEY = "AKIAIMNO78987SAMPLEKEY/bXU8JEIKN89098"\u000aSTRIPE_API_KEY = "sk_test_4eC39HqLyjWDarjtT1zdp7dc"\u000aDEBUG_PASSWORD = "admin_password_123!"\u000a\u000aWEAK_KEY = b''PR6H93e48950S3Kcy04R0S4R85E6p287'' # Hardcoded\u000acipher = Fernet(base64.urlsafe_b64encode(b"static_key_12345")) \u000a'),NULL,NULL,NULL,NULL,NULL,NULL,0,NULL,NULL,NULL);
INSERT INTO findings VALUES(19,3,NULL,NULL,'Gitleaks','stripe-access-token','not_secure.py',12,'Found a Stripe Access Token, posing a risk to payment processing services and sensitive financial data.',unistr('from cryptography.fernet import Fernet\u000a\u000aapp = FastAPI()\u000a\u000aAWS_SECRET_KEY = "AKIAIMNO78987SAMPLEKEY/bXU8JEIKN89098"\u000aSTRIPE_API_KEY = "sk_test_4eC39HqLyjWDarjtT1zdp7dc"\u000aDEBUG_PASSWORD = "admin_password_123!"\u000a\u000aWEAK_KEY = b''PR6H93e48950S3Kcy04R0S4R85E6p287'' # Hardcoded\u000acipher = Fernet(base64.urlsafe_b64encode(b"static_key_12345")) \u000a'),NULL,NULL,NULL,NULL,NULL,NULL,0,NULL,NULL,NULL);
INSERT INTO findings VALUES(20,3,NULL,NULL,'Gitleaks','stripe-access-token','not_secure.py',8,'Found a Stripe Access Token, posing a risk to payment processing services and sensitive financial data.',unistr('import subprocess\u000aimport base64\u000aimport pickle\u000afrom fastapi import FastAPI, Request\u000afrom cryptography.fernet import Fernet\u000a\u000aapp = FastAPI()\u000a\u000aAWS_SECRET_KEY = "AKIAIMNO78987SAMPLEKEY/bXU8JEIKN89098"\u000aSTRIPE_API_KEY = "sk_test_4eC39HqLyjWDarjtT1zdp7dc"\u000a'),NULL,NULL,NULL,NULL,NULL,NULL,0,NULL,NULL,NULL);
INSERT INTO findings VALUES(21,4,NULL,unistr('\u000a--- RED_TEAM_POC (SUCCESS: False) ---\u000a  File "/app/poc_exploit.py", line 1\u000a    ```python\u000a    ^\u000aSyntaxError: invalid syntax\u000a\u000a\u000a--- SANITY_CHECK (SUCCESS: True) ---\u000aPatch looks valid.\u000a'),'Semgrep OSS','python.lang.security.audit.formatted-sql-query.formatted-sql-query','not_secure.py',24,'Detected possible formatted SQL query. Use parameterized queries instead.',unistr('def get_user(user_id: str):\u000a    conn = sqlite3.connect(''users.db'')\u000a    cursor = conn.cursor()\u000a    # DANGEROUS: Direct string formatting into SQL\u000a    query = f"SELECT * FROM users WHERE id = ''{user_id}''"\u000a    cursor.execute(query)\u000a    return cursor.fetchone()\u000a\u000a@app.get("/ping")\u000adef ping_host(host: str):\u000a'),NULL,NULL,NULL,5.0,'Medium',NULL,0,NULL,NULL,NULL);
INSERT INTO findings VALUES(22,4,NULL,unistr('\u000a--- RED_TEAM_POC (SUCCESS: False) ---\u000a  File "/app/poc_exploit.py", line 1\u000a    ```python\u000a    ^\u000aSyntaxError: invalid syntax\u000a\u000a\u000a--- SANITY_CHECK (SUCCESS: True) ---\u000aPatch looks valid.\u000a'),'Semgrep OSS','python.sqlalchemy.security.sqlalchemy-execute-raw-query.sqlalchemy-execute-raw-query','not_secure.py',24,'Avoiding SQL string concatenation: untrusted input concatenated with raw SQL query can result in SQL Injection. In order to execute raw query safely, prepared statement should be used. SQLAlchemy provides TextualSQL to easily used prepared statement with named parameters. For complex SQL composition, use SQL Expression Language or Schema Definition Language. In most cases, SQLAlchemy ORM will be a better option.',unistr('def get_user(user_id: str):\u000a    conn = sqlite3.connect(''users.db'')\u000a    cursor = conn.cursor()\u000a    # DANGEROUS: Direct string formatting into SQL\u000a    query = f"SELECT * FROM users WHERE id = ''{user_id}''"\u000a    cursor.execute(query)\u000a    return cursor.fetchone()\u000a\u000a@app.get("/ping")\u000adef ping_host(host: str):\u000a'),NULL,NULL,NULL,8.0,'High',NULL,0,NULL,NULL,NULL);
INSERT INTO findings VALUES(23,4,NULL,unistr('\u000a--- RED_TEAM_POC (SUCCESS: False) ---\u000a  File "/app/poc_exploit.py", line 1\u000a    ```python\u000a    ^\u000aSyntaxError: invalid syntax\u000a\u000a\u000a--- SANITY_CHECK (SUCCESS: True) ---\u000aPatch looks valid.\u000a'),'Semgrep OSS','python.lang.security.audit.subprocess-shell-true.subprocess-shell-true','not_secure.py',31,'Found ''subprocess'' function ''check_output'' with ''shell=True''. This is dangerous because this call will spawn the command using a shell process. Doing so propagates current shell settings and variables, which makes it much easier for a malicious actor to execute commands. Use ''shell=False'' instead.',unistr('\u000a@app.get("/ping")\u000adef ping_host(host: str):\u000a    # DANGEROUS: User input passed directly to shell\u000a    # An attacker could send: "8.8.8.8; rm -rf /"\u000a    result = subprocess.check_output(f"ping -c 1 {host}", shell=True)\u000a    return {"output": result.decode()}\u000a\u000aimport pickle\u000a@app.post("/load_profile")\u000a'),NULL,NULL,NULL,5.0,'Medium',NULL,0,NULL,NULL,NULL);
INSERT INTO findings VALUES(24,4,NULL,NULL,'Semgrep OSS','python.django.security.audit.avoid-insecure-deserialization.avoid-insecure-deserialization','not_secure.py',39,'Avoid using insecure deserialization library, backed by `pickle`, `_pickle`, `cpickle`, `dill`, `shelve`, or `yaml`, which are known to lead to remote code execution vulnerabilities.',unistr('import pickle\u000a@app.post("/load_profile")\u000aasync def load_profile(request: Request):\u000a    data = await request.body()\u000a    # DANGEROUS: Unpickling untrusted data leads to RCE\u000a    profile = pickle.loads(data)\u000a    return {"profile": "loaded"}\u000a\u000adef run_user_command(user_input):\u000a    return subprocess.check_output(user_input, shell=True)\u000a'),NULL,NULL,NULL,NULL,NULL,NULL,0,NULL,NULL,NULL);
INSERT INTO findings VALUES(25,4,NULL,NULL,'Semgrep OSS','python.lang.security.deserialization.pickle.avoid-pickle','not_secure.py',39,'Avoid using `pickle`, which is known to lead to code execution vulnerabilities. When unpickling, the serialized data could be manipulated to run arbitrary code. Instead, consider serializing the relevant data as JSON or a similar text-based serialization format.',unistr('import pickle\u000a@app.post("/load_profile")\u000aasync def load_profile(request: Request):\u000a    data = await request.body()\u000a    # DANGEROUS: Unpickling untrusted data leads to RCE\u000a    profile = pickle.loads(data)\u000a    return {"profile": "loaded"}\u000a\u000adef run_user_command(user_input):\u000a    return subprocess.check_output(user_input, shell=True)\u000a'),NULL,NULL,NULL,NULL,NULL,NULL,0,NULL,NULL,NULL);
INSERT INTO findings VALUES(26,4,NULL,NULL,'Semgrep OSS','python.lang.security.audit.subprocess-shell-true.subprocess-shell-true','not_secure.py',43,'Found ''subprocess'' function ''check_output'' with ''shell=True''. This is dangerous because this call will spawn the command using a shell process. Doing so propagates current shell settings and variables, which makes it much easier for a malicious actor to execute commands. Use ''shell=False'' instead.',unistr('    # DANGEROUS: Unpickling untrusted data leads to RCE\u000a    profile = pickle.loads(data)\u000a    return {"profile": "loaded"}\u000a\u000adef run_user_command(user_input):\u000a    return subprocess.check_output(user_input, shell=True)\u000a\u000adef load_user_data(serialized_data):\u000a    return pickle.loads(serialized_data)\u000a\u000a'),NULL,NULL,NULL,NULL,NULL,NULL,0,NULL,NULL,NULL);
INSERT INTO findings VALUES(27,4,NULL,NULL,'Semgrep OSS','python.lang.security.deserialization.pickle.avoid-pickle','not_secure.py',46,'Avoid using `pickle`, which is known to lead to code execution vulnerabilities. When unpickling, the serialized data could be manipulated to run arbitrary code. Instead, consider serializing the relevant data as JSON or a similar text-based serialization format.',unistr('\u000adef run_user_command(user_input):\u000a    return subprocess.check_output(user_input, shell=True)\u000a\u000adef load_user_data(serialized_data):\u000a    return pickle.loads(serialized_data)\u000a\u000a"""\u000aDOCKERFILE HINT (for Checkov testing):\u000aFROM python:3.8-slim\u000a'),NULL,NULL,NULL,NULL,NULL,NULL,0,NULL,NULL,NULL);
INSERT INTO findings VALUES(28,4,NULL,NULL,'Trivy','stripe-secret-token','not_secure.py',12,unistr('Artifact: not_secure.py\u000aType: \u000aSecret Stripe Secret Key\u000aSeverity: CRITICAL\u000aMatch: STRIPE_API_KEY = "********************************"'),unistr('from cryptography.fernet import Fernet\u000a\u000aapp = FastAPI()\u000a\u000aAWS_SECRET_KEY = "AKIAIMNO78987SAMPLEKEY/bXU8JEIKN89098"\u000aSTRIPE_API_KEY = "sk_test_4eC39HqLyjWDarjtT1zdp7dc"\u000aDEBUG_PASSWORD = "admin_password_123!"\u000a\u000aWEAK_KEY = b''PR6H93e48950S3Kcy04R0S4R85E6p287'' # Hardcoded\u000acipher = Fernet(base64.urlsafe_b64encode(b"static_key_12345")) \u000a'),NULL,NULL,NULL,NULL,NULL,NULL,0,NULL,NULL,NULL);
INSERT INTO findings VALUES(29,4,NULL,NULL,'Gitleaks','stripe-access-token','not_secure.py',12,'Found a Stripe Access Token, posing a risk to payment processing services and sensitive financial data.',unistr('from cryptography.fernet import Fernet\u000a\u000aapp = FastAPI()\u000a\u000aAWS_SECRET_KEY = "AKIAIMNO78987SAMPLEKEY/bXU8JEIKN89098"\u000aSTRIPE_API_KEY = "sk_test_4eC39HqLyjWDarjtT1zdp7dc"\u000aDEBUG_PASSWORD = "admin_password_123!"\u000a\u000aWEAK_KEY = b''PR6H93e48950S3Kcy04R0S4R85E6p287'' # Hardcoded\u000acipher = Fernet(base64.urlsafe_b64encode(b"static_key_12345")) \u000a'),NULL,NULL,NULL,NULL,NULL,NULL,0,NULL,NULL,NULL);
INSERT INTO findings VALUES(30,4,NULL,NULL,'Gitleaks','stripe-access-token','not_secure.py',8,'Found a Stripe Access Token, posing a risk to payment processing services and sensitive financial data.',unistr('import subprocess\u000aimport base64\u000aimport pickle\u000afrom fastapi import FastAPI, Request\u000afrom cryptography.fernet import Fernet\u000a\u000aapp = FastAPI()\u000a\u000aAWS_SECRET_KEY = "AKIAIMNO78987SAMPLEKEY/bXU8JEIKN89098"\u000aSTRIPE_API_KEY = "sk_test_4eC39HqLyjWDarjtT1zdp7dc"\u000a'),NULL,NULL,NULL,NULL,NULL,NULL,0,NULL,NULL,NULL);
INSERT INTO findings VALUES(31,5,'FP',NULL,'Semgrep','python.lang.security.audit.dangerous-system-call','app.py',0,'Potential Command Injection',unistr('import os\u000a\u000adef process_request(user_input):\u000a    # Vulnerable to Command Injection\u000a'),'FP',NULL,NULL,1.0,'Low',NULL,0,NULL,NULL,NULL);
INSERT INTO findings VALUES(32,6,'RV',unistr('\\n--- RED_TEAM_POC (SUCCESS: False) ---\\n  File "/app/poc_exploit.py", line 1\u000a    ```python\u000a    ^\u000aSyntaxError: invalid syntax\u000a\\n'),'Semgrep OSS','python.lang.security.audit.formatted-sql-query.formatted-sql-query','not_secure.py',24,'Detected possible formatted SQL query. Use parameterized queries instead.',unistr('def get_user(user_id: str):\u000a    conn = sqlite3.connect(''users.db'')\u000a    cursor = conn.cursor()\u000a    # DANGEROUS: Direct string formatting into SQL\u000a    query = f"SELECT * FROM users WHERE id = ''{user_id}''"\u000a    cursor.execute(query)\u000a    return cursor.fetchone()\u000a\u000a@app.get("/ping")\u000adef ping_host(host: str):\u000a'),'TP',NULL,NULL,5.0,'Medium',unistr('import sqlite3\u000afrom fastapi import FastAPI\u000a\u000aapp = FastAPI()\u000a\u000a\u000adef get_user(user_id: str):\u000a    """\u000a    Retrieve a user record from the SQLite database using a parameterized query.\u000a    """\u000a    # Use a context manager to ensure the connection is closed automatically.\u000a    with sqlite3.connect("users.db") as conn:\u000a        cursor = conn.cursor()\u000a        # Parameterized query prevents SQL injection\u000a        query = "SELECT * FROM users WHERE id = ?"\u000a        cursor.execute(query, (user_id,))\u000a        return cursor.fetchone()\u000a\u000a\u000a@app.get("/ping")\u000aasync def ping_host(host: str):\u000a    """\u000a    Simple health‑check endpoint that echoes the supplied host.\u000a    """\u000a    return {"message": f"Pong to {host}"}'),0,unistr('  File "/app/poc_exploit.py", line 1\u000a    ```python\u000a    ^\u000aSyntaxError: invalid syntax\u000a'),'https://github.com/AnaaaKareem/devsecops-test/pull/28',NULL);
INSERT INTO findings VALUES(33,6,'RV',unistr('\\n--- RED_TEAM_POC (SUCCESS: False) ---\\n  File "/app/poc_exploit.py", line 1\u000a    ```python\u000a    ^\u000aSyntaxError: invalid syntax\u000a\\n'),'Semgrep OSS','python.sqlalchemy.security.sqlalchemy-execute-raw-query.sqlalchemy-execute-raw-query','not_secure.py',24,'Avoiding SQL string concatenation: untrusted input concatenated with raw SQL query can result in SQL Injection. In order to execute raw query safely, prepared statement should be used. SQLAlchemy provides TextualSQL to easily used prepared statement with named parameters. For complex SQL composition, use SQL Expression Language or Schema Definition Language. In most cases, SQLAlchemy ORM will be a better option.',unistr('def get_user(user_id: str):\u000a    conn = sqlite3.connect(''users.db'')\u000a    cursor = conn.cursor()\u000a    # DANGEROUS: Direct string formatting into SQL\u000a    query = f"SELECT * FROM users WHERE id = ''{user_id}''"\u000a    cursor.execute(query)\u000a    return cursor.fetchone()\u000a\u000a@app.get("/ping")\u000adef ping_host(host: str):\u000a'),'TP',NULL,NULL,8.0,'High',unistr('import sqlite3\u000afrom fastapi import FastAPI\u000a\u000aapp = FastAPI()\u000a\u000a\u000adef get_user(user_id: str):\u000a    """\u000a    Retrieve a user record from the SQLite database safely using a parameterized query.\u000a    """\u000a    # Use a context manager to ensure the connection is closed properly\u000a    with sqlite3.connect("users.db") as conn:\u000a        cursor = conn.cursor()\u000a        # Parameterised SQL – no string interpolation!\u000a        sql = "SELECT * FROM users WHERE id = ?"\u000a        cursor.execute(sql, (user_id,))\u000a        return cursor.fetchone()\u000a\u000a\u000a@app.get("/ping")\u000adef ping_host(host: str):\u000a    """\u000a    Simple health‑check endpoint.  The `host` parameter is accepted but not used\u000a    in this example – it can be extended to perform an actual ping.\u000a    """\u000a    # Placeholder implementation – just echo back a status\u000a    return {"status": "ok"}'),0,unistr('  File "/app/poc_exploit.py", line 1\u000a    ```python\u000a    ^\u000aSyntaxError: invalid syntax\u000a'),'https://github.com/AnaaaKareem/devsecops-test/pull/28',NULL);
INSERT INTO findings VALUES(34,6,'RV',unistr('\\n--- RED_TEAM_POC (SUCCESS: False) ---\\n  File "/app/poc_exploit.py", line 1\u000a    ```python\u000a    ^\u000aSyntaxError: invalid syntax\u000a\\n'),'Semgrep OSS','python.lang.security.audit.subprocess-shell-true.subprocess-shell-true','not_secure.py',31,'Found ''subprocess'' function ''check_output'' with ''shell=True''. This is dangerous because this call will spawn the command using a shell process. Doing so propagates current shell settings and variables, which makes it much easier for a malicious actor to execute commands. Use ''shell=False'' instead.',unistr('\u000a@app.get("/ping")\u000adef ping_host(host: str):\u000a    # DANGEROUS: User input passed directly to shell\u000a    # An attacker could send: "8.8.8.8; rm -rf /"\u000a    result = subprocess.check_output(f"ping -c 1 {host}", shell=True)\u000a    return {"output": result.decode()}\u000a\u000aimport pickle\u000a@app.post("/load_profile")\u000a'),'TP',NULL,NULL,5.0,'Medium',unistr('from fastapi import FastAPI\u000aimport subprocess\u000a\u000aapp = FastAPI()\u000a\u000a\u000a@app.get("/ping")\u000adef ping_host(host: str):\u000a    """\u000a    Ping a host safely without using shell=True.\u000a    The command is passed as a list of arguments, so no shell expansion occurs.\u000a    """\u000a    # Execute the ping command with a fixed argument list to avoid shell injection\u000a    result = subprocess.check_output(\u000a        ["ping", "-c", "1", host],\u000a        stderr=subprocess.STDOUT,\u000a    )\u000a    return {"output": result.decode()}\u000a\u000a\u000a@app.post("/load_profile")\u000adef load_profile():\u000a    """\u000a    Placeholder for the /load_profile endpoint.\u000a    Add your implementation here.\u000a    """\u000a    # TODO: implement profile loading logic\u000a    pass'),0,unistr('  File "/app/poc_exploit.py", line 1\u000a    ```python\u000a    ^\u000aSyntaxError: invalid syntax\u000a'),'https://github.com/AnaaaKareem/devsecops-test/pull/28',NULL);
INSERT INTO findings VALUES(35,6,'RV',unistr('\\n--- RED_TEAM_POC (SUCCESS: False) ---\\n  File "/app/poc_exploit.py", line 1\u000a    ```python\u000a    ^\u000aSyntaxError: invalid syntax\u000a\\n'),'Semgrep OSS','python.django.security.audit.avoid-insecure-deserialization.avoid-insecure-deserialization','not_secure.py',39,'Avoid using insecure deserialization library, backed by `pickle`, `_pickle`, `cpickle`, `dill`, `shelve`, or `yaml`, which are known to lead to remote code execution vulnerabilities.',unistr('import pickle\u000a@app.post("/load_profile")\u000aasync def load_profile(request: Request):\u000a    data = await request.body()\u000a    # DANGEROUS: Unpickling untrusted data leads to RCE\u000a    profile = pickle.loads(data)\u000a    return {"profile": "loaded"}\u000a\u000adef run_user_command(user_input):\u000a    return subprocess.check_output(user_input, shell=True)\u000a'),'TP',NULL,NULL,8.0,'High',unistr('import json\u000afrom fastapi import Request\u000a\u000a# NOTE: The `app` instance is assumed to be defined elsewhere in the application.\u000a@app.post("/load_profile")\u000aasync def load_profile(request: Request):\u000a    # Retrieve raw request body bytes\u000a    data_bytes = await request.body()\u000a\u000a    try:\u000a        # Convert bytes to a UTF‑8 string and safely parse JSON\u000a        payload_str = data_bytes.decode("utf-8")\u000a        profile_data = json.loads(payload_str)\u000a    except (UnicodeDecodeError, json.JSONDecodeError) as exc:\u000a        # Return an error response if the body is not valid JSON\u000a        return {"error": f"Invalid request payload: {exc}"}\u000a\u000a    # Here you would normally process `profile_data` – e.g. store it or use it.\u000a    # For demonstration purposes we simply acknowledge receipt.\u000a    return {"profile": "loaded"}\u000a\u000adef run_user_command(user_input):\u000a    """\u000a    Execute a shell command and return its output.\u000a\u000a    WARNING: Using `shell=True` can be dangerous if `user_input`\u000a    contains untrusted data.  In production code you should avoid this\u000a    or sanitize the input thoroughly.\u000a    """\u000a    return subprocess.check_output(user_input, shell=True)'),0,unistr('  File "/app/poc_exploit.py", line 1\u000a    ```python\u000a    ^\u000aSyntaxError: invalid syntax\u000a'),'https://github.com/AnaaaKareem/devsecops-test/pull/28',NULL);
INSERT INTO findings VALUES(36,6,'RV',unistr('\\n--- RED_TEAM_POC (SUCCESS: False) ---\\n  File "/app/poc_exploit.py", line 1\u000a    ```python\u000a    ^\u000aSyntaxError: invalid syntax\u000a\\n'),'Semgrep OSS','python.lang.security.deserialization.pickle.avoid-pickle','not_secure.py',39,'Avoid using `pickle`, which is known to lead to code execution vulnerabilities. When unpickling, the serialized data could be manipulated to run arbitrary code. Instead, consider serializing the relevant data as JSON or a similar text-based serialization format.',unistr('import pickle\u000a@app.post("/load_profile")\u000aasync def load_profile(request: Request):\u000a    data = await request.body()\u000a    # DANGEROUS: Unpickling untrusted data leads to RCE\u000a    profile = pickle.loads(data)\u000a    return {"profile": "loaded"}\u000a\u000adef run_user_command(user_input):\u000a    return subprocess.check_output(user_input, shell=True)\u000a'),'TP',NULL,NULL,5.0,'Medium',unistr('import json\u000aimport subprocess\u000afrom typing import Dict, Any\u000a\u000afrom fastapi import FastAPI, Request, HTTPException\u000a\u000aapp = FastAPI()\u000a\u000a\u000a@app.post("/load_profile")\u000aasync def load_profile(request: Request):\u000a    """\u000a    Accepts a JSON payload representing a user profile.\u000a    The payload is parsed safely using the built‑in json module,\u000a    eliminating the risk of executing arbitrary code that would arise\u000a    from untrusted pickle data.\u000a    """\u000a    body_bytes = await request.body()\u000a    try:\u000a        # Decode bytes to string and parse as JSON\u000a        profile_data: Dict[str, Any] = json.loads(body_bytes.decode("utf-8"))\u000a    except (json.JSONDecodeError, UnicodeDecodeError) as exc:\u000a        raise HTTPException(status_code=400, detail="Invalid JSON payload") from exc)\u000a\u000a    # Here you would normally process the profile data.\u000a    # For demonstration we simply echo it back.\u000a    return {"profile": profile_data}\u000a\u000a\u000adef run_user_command(user_input: str) -> str:\u000a    """\u000a    Executes a shell command in a safe manner.\u000a\u000a    Only commands that are explicitly whitelisted are allowed.  This\u000a    prevents arbitrary code execution while still providing a minimal\u000a    example of how one might safely execute external programs.\u000a    """\u000a    # Define a small whitelist of harmless commands for demo purposes.\u000a    ALLOWED_COMMANDS = {"echo", "date", "whoami"}\u000a\u000a    # Split the input into arguments; this avoids shell=True and its\u000a    # associated injection risks.\u000a    cmd_parts = user_input.strip().split()\u000a    if not cmd_parts:\u000a        raise ValueError("No command provided")\u000a\u000a    if cmd_parts[0] not in ALLOWED_COMMANDS:\u000a        raise PermissionError(f"Command ''{cmd_parts[0]}'' is not allowed")\u000a\u000a    try:\u000a        # Execute the command safely without invoking a shell.\u000a        output = subprocess.check_output(cmd_parts, text=True)\u000a    except subprocess.SubprocessError as exc:\u000a        raise RuntimeError("Failed to execute command") from exc\u000a\u000a    return output'),0,unistr('  File "/app/poc_exploit.py", line 1\u000a    ```python\u000a    ^\u000aSyntaxError: invalid syntax\u000a'),'https://github.com/AnaaaKareem/devsecops-test/pull/28',NULL);
INSERT INTO findings VALUES(37,6,'RV',unistr('\\n--- RED_TEAM_POC (SUCCESS: False) ---\\n  File "/app/poc_exploit.py", line 1\u000a    ```python\u000a    ^\u000aSyntaxError: invalid syntax\u000a\\n'),'Semgrep OSS','python.lang.security.audit.subprocess-shell-true.subprocess-shell-true','not_secure.py',43,'Found ''subprocess'' function ''check_output'' with ''shell=True''. This is dangerous because this call will spawn the command using a shell process. Doing so propagates current shell settings and variables, which makes it much easier for a malicious actor to execute commands. Use ''shell=False'' instead.',unistr('    # DANGEROUS: Unpickling untrusted data leads to RCE\u000a    profile = pickle.loads(data)\u000a    return {"profile": "loaded"}\u000a\u000adef run_user_command(user_input):\u000a    return subprocess.check_output(user_input, shell=True)\u000a\u000adef load_user_data(serialized_data):\u000a    return pickle.loads(serialized_data)\u000a\u000a'),'TP',NULL,NULL,5.0,'Medium',unistr('import json\u000aimport shlex\u000aimport subprocess\u000a\u000a# ------------------------------------------------------------------\u000a# Safe data handling – avoid untrusted pickles\u000a# ------------------------------------------------------------------\u000adef load_user_data(serialized_data):\u000a    """\u000a    Load user data from a JSON string instead of an unsafe pickle.\u000a    Parameters:\u000a        serialized_data (str): A JSON‑encoded string containing the user data.\u000a\u000a    Returns:\u000a        dict: The deserialized user data.\u000a    """\u000a    return json.loads(serialized_data)\u000a\u000a\u000a# ------------------------------------------------------------------\u000a# Safe command execution – never use shell=True with untrusted input\u000a# ------------------------------------------------------------------\u000adef run_user_command(user_input):\u000a    """\u000a    Execute a user‑supplied command safely without invoking the shell.\u000a\u000a    Parameters:\u000a        user_input (str | list[str]): The command to execute. If a string is supplied,\u000a            it will be split into arguments using shlex.split().\u000a\u000a    Returns:\u000a        bytes: The stdout of the executed command.\u000a    """\u000a    # Convert a raw string into a list of arguments safely\u000a    if isinstance(user_input, str):\u000a        args = shlex.split(user_input)\u000a    else:\u000a        args = user_input\u000a\u000a    # Execute without shell to avoid injection attacks\u000a    return subprocess.check_output(args, shell=False)\u000a\u000a\u000a# ------------------------------------------------------------------\u000a# Example usage – loading a profile from JSON (previously unsafe pickle)\u000a# ------------------------------------------------------------------\u000adef load_profile(data: str):\u000a    """\u000a    Load a user profile safely from a JSON string.\u000a\u000a    Parameters:\u000a        data (str): JSON‑encoded profile information.\u000a\u000a    Returns:\u000a        dict: The loaded profile.\u000a    """\u000a    return {"profile": json.loads(data)}'),0,unistr('  File "/app/poc_exploit.py", line 1\u000a    ```python\u000a    ^\u000aSyntaxError: invalid syntax\u000a'),'https://github.com/AnaaaKareem/devsecops-test/pull/28',NULL);
INSERT INTO findings VALUES(38,6,'RV',unistr('\\n--- RED_TEAM_POC (SUCCESS: True) ---\\n\u000a=== Command Injection Demo ===\u000aCommand output: Hello from injected code\u000a[+] File /tmp/injected_file successfully created by shell injection!\u000a\u000a=== Pickle Deserialization Demo ===\u000a[+] File /tmp/pickle_evil successfully created by pickle deserialization!\u000a\\n'),'Semgrep OSS','python.lang.security.deserialization.pickle.avoid-pickle','not_secure.py',46,'Avoid using `pickle`, which is known to lead to code execution vulnerabilities. When unpickling, the serialized data could be manipulated to run arbitrary code. Instead, consider serializing the relevant data as JSON or a similar text-based serialization format.',unistr('\u000adef run_user_command(user_input):\u000a    return subprocess.check_output(user_input, shell=True)\u000a\u000adef load_user_data(serialized_data):\u000a    return pickle.loads(serialized_data)\u000a\u000a"""\u000aDOCKERFILE HINT (for Checkov testing):\u000aFROM python:3.8-slim\u000a'),'TP',NULL,NULL,10.0,'Critical',unistr('import subprocess\u000aimport json\u000a\u000a\u000adef run_user_command(user_input: str) -> bytes:\u000a    """\u000a    Execute a shell command supplied by the user.\u000a\u000a    Note: Using `shell=True` can be dangerous if the input is not trusted.\u000a    Ensure that `user_input` comes from a safe source or is properly sanitized.\u000a    """\u000a    return subprocess.check_output(user_input, shell=True)\u000a\u000a\u000adef load_user_data(serialized_data):\u000a    """\u000a    Safely deserialize user data.\u000a\u000a    The original implementation used :py:func:`pickle.loads`, which can execute arbitrary code\u000a    during deserialization.  This function now expects the data to be in JSON format,\u000a    which is safe for plain text serialization and does not allow arbitrary code execution.\u000a    """\u000a    # Accept both bytes (e.g., from a file) or a string representation of JSON.\u000a    if isinstance(serialized_data, (bytes, bytearray)):\u000a        try:\u000a            data_str = serialized_data.decode("utf-8")\u000a        except UnicodeDecodeError as exc:\u000a            raise ValueError("Serialized data must be UTF‑8 encoded") from exc\u000a    else:\u000a        # Treat any other type as a string representation of JSON.\u000a        data_str = str(serialized_data)\u000a\u000a    try:\u000a        return json.loads(data_str)\u000a    except json.JSONDecodeError as exc:\u000a        raise ValueError("Invalid JSON data") from exc'),1,unistr('\u000a=== Command Injection Demo ===\u000aCommand output: Hello from injected code\u000a[+] File /tmp/injected_file successfully created by shell injection!\u000a\u000a=== Pickle Deserialization Demo ===\u000a[+] File /tmp/pickle_evil successfully created by pickle deserialization!\u000a'),'https://github.com/AnaaaKareem/devsecops-test/pull/28',NULL);
INSERT INTO findings VALUES(39,6,'RV',unistr('\\n--- RED_TEAM_POC (SUCCESS: False) ---\\n  File "/app/poc_exploit.py", line 1\u000a    ```python\u000a    ^\u000aSyntaxError: invalid syntax\u000a\\n'),'Trivy','stripe-secret-token','not_secure.py',12,unistr('Artifact: not_secure.py\u000aType: \u000aSecret Stripe Secret Key\u000aSeverity: CRITICAL\u000aMatch: STRIPE_API_KEY = "********************************"'),unistr('from cryptography.fernet import Fernet\u000a\u000aapp = FastAPI()\u000a\u000aAWS_SECRET_KEY = "AKIAIMNO78987SAMPLEKEY/bXU8JEIKN89098"\u000aSTRIPE_API_KEY = "sk_test_4eC39HqLyjWDarjtT1zdp7dc"\u000aDEBUG_PASSWORD = "admin_password_123!"\u000a\u000aWEAK_KEY = b''PR6H93e48950S3Kcy04R0S4R85E6p287'' # Hardcoded\u000acipher = Fernet(base64.urlsafe_b64encode(b"static_key_12345")) \u000a'),'TP',NULL,NULL,5.0,'Medium',unistr('# secure_config.py\u000a\u000aimport os\u000afrom fastapi import FastAPI\u000afrom cryptography.fernet import Fernet\u000aimport base64\u000aimport secrets\u000a\u000a# --------------------------------------------------------------------------- #\u000a# 1️⃣ Load sensitive values from environment variables (never hard‑code them)\u000a# --------------------------------------------------------------------------- #\u000a\u000adef _get_env(name: str, default: str | None = None) -> str:\u000a    """Return the value of an environment variable or raise if missing."""\u000a    val = os.getenv(name)\u000a    if val is None:\u000a        if default is not None:\u000a            return default\u000a        raise RuntimeError(f"Missing required environment variable: {name}")\u000a    return val\u000a\u000a\u000a# --------------------------------------------------------------------------- #\u000a# 2️⃣ Initialise FastAPI application\u000a# --------------------------------------------------------------------------- #\u000a\u000aapp = FastAPI(title="Secure API")\u000a\u000a# --------------------------------------------------------------------------- #\u000a# 3️⃣ Securely obtain the Stripe secret key (or any other secrets)\u000a# --------------------------------------------------------------------------- #\u000a\u000aSTRIPE_API_KEY = _get_env("STRIPE_API_KEY")\u000aAWS_SECRET_KEY = _get_env("AWS_SECRET_KEY")\u000a\u000a# --------------------------------------------------------------------------- #\u000a# 4️⃣ Remove hard‑coded debug credentials\u000a# --------------------------------------------------------------------------- #\u000a# DEBUG_PASSWORD is intentionally omitted – never store plain passwords in code.\u000a\u000a# --------------------------------------------------------------------------- #\u000a# 5️⃣ Create a Fernet cipher with a key that is **not** derived from static data.\u000a# --------------------------------------------------------------------------- #\u000a\u000a# Prefer to load an encryption key from the environment; if it does not exist,\u000a# generate one at runtime (this will be lost on restart, which is fine for\u000a# demo purposes – in production you would persist the key securely).\u000aENCRYPTION_KEY = os.getenv("FERNET_KEY")\u000aif ENCRYPTION_KEY:\u000a    # The key must be 32 url‑safe base64 bytes.\u000a    fernet_key = base64.urlsafe_b64decode(ENCRYPTION_KEY)\u000aelse:\u000a    # Generate a fresh key for this instance\u000a    fernet_key = Fernet.generate_key()\u000a\u000acipher = Fernet(fernet_key)\u000a\u000a# --------------------------------------------------------------------------- #\u000a# 6️⃣ Example endpoint that uses the cipher (optional)\u000a# --------------------------------------------------------------------------- #\u000a\u000a@app.get("/encrypt")\u000adef encrypt_endpoint(value: str):\u000a    """Return an encrypted version of the supplied value."""\u000a    return {"encrypted": cipher.encrypt(value.encode()).decode()}\u000a\u000a@app.get("/decrypt")\u000adef decrypt_endpoint(token: str):\u000a    """Return a decrypted version of the supplied token."""\u000a    return {"decrypted": cipher.decrypt(token.encode()).decode()}'),0,unistr('  File "/app/poc_exploit.py", line 1\u000a    ```python\u000a    ^\u000aSyntaxError: invalid syntax\u000a'),'https://github.com/AnaaaKareem/devsecops-test/pull/28',NULL);
INSERT INTO findings VALUES(40,6,'RV',unistr('\\n--- RED_TEAM_POC (SUCCESS: False) ---\\n  File "/app/poc_exploit.py", line 1\u000a    ```python\u000a    ^\u000aSyntaxError: invalid syntax\u000a\\n'),'Gitleaks','stripe-access-token','not_secure.py',12,'Found a Stripe Access Token, posing a risk to payment processing services and sensitive financial data.',unistr('from cryptography.fernet import Fernet\u000a\u000aapp = FastAPI()\u000a\u000aAWS_SECRET_KEY = "AKIAIMNO78987SAMPLEKEY/bXU8JEIKN89098"\u000aSTRIPE_API_KEY = "sk_test_4eC39HqLyjWDarjtT1zdp7dc"\u000aDEBUG_PASSWORD = "admin_password_123!"\u000a\u000aWEAK_KEY = b''PR6H93e48950S3Kcy04R0S4R85E6p287'' # Hardcoded\u000acipher = Fernet(base64.urlsafe_b64encode(b"static_key_12345")) \u000a'),'TP',NULL,NULL,5.0,'Medium',unistr('import os\u000afrom fastapi import FastAPI, HTTPException\u000a\u000a# Import the Fernet class from the cryptography library\u000afrom cryptography.fernet import Fernet\u000a\u000a\u000aapp = FastAPI()\u000a\u000a\u000a# ------------------------------------------------------------------\u000a# 1️⃣ Load secrets securely – never hard‑code them in source code.\u000a# ------------------------------------------------------------------\u000aAWS_SECRET_KEY: str | None = os.getenv("AWS_SECRET_KEY")\u000aSTRIPE_API_KEY: str | None = os.getenv("STRIPE_API_KEY")\u000a\u000aif not AWS_SECRET_KEY or not STRIPE_API_KEY:\u000a    # In a real deployment you would raise an error or exit the process\u000a    # so that the application does not run with missing credentials.\u000a    raise RuntimeError(\u000a        "Missing required secret environment variables: "\u000a        "AWS_SECRET_KEY and/or STRIPE_API_KEY"\u000a    )\u000a\u000a\u000a# ------------------------------------------------------------------\u000a# 2️⃣ Create a Fernet cipher instance using a key from an env var.\u000a# ------------------------------------------------------------------\u000a# The key must be a URL‑safe base64 encoded 32‑byte value.  In production\u000a# you would store this in a secrets manager or vault and load it at runtime.\u000aFERNET_KEY: bytes | None = os.getenv("FERNET_KEY")\u000aif not FERNET_KEY:\u000a    # For demonstration purposes we generate a key here – do NOT use this in prod!\u000a    FERNET_KEY = Fernet.generate_key()\u000a\u000a# Initialise the cipher\u000acipher = Fernet(FERNET_KEY)\u000a\u000a\u000a# ------------------------------------------------------------------\u000a# 3️⃣ Example endpoints that demonstrate encryption/decryption.\u000a# ------------------------------------------------------------------\u000a@app.get("/encrypt")\u000adef encrypt_data(data: str):\u000a    """\u000a    Encrypt a plain‑text string and return the base64 token.\u000a    """\u000a    encrypted_bytes = cipher.encrypt(data.encode("utf-8"))\u000a    # Return as a UTF‑8 string so it can be sent over JSON\u000a    return {"encrypted": encrypted_bytes.decode("utf-8")}\u000a\u000a\u000a@app.get("/decrypt")\u000adef decrypt_data(token: str):\u000a    """\u000a    Decrypt a previously generated token.\u000a    """\u000a    try:\u000a        decrypted_bytes = cipher.decrypt(token.encode("utf-8"))\u000a    except Exception as exc:\u000a        # If decryption fails we return a 400 – the caller supplied an invalid token\u000a        raise HTTPException(\u000a            status_code=400,\u000a            detail="Invalid or expired token",\u000a        ) from exc\u000a\u000a    return {"decrypted": decrypted_bytes.decode("utf-8")}'),0,unistr('  File "/app/poc_exploit.py", line 1\u000a    ```python\u000a    ^\u000aSyntaxError: invalid syntax\u000a'),'https://github.com/AnaaaKareem/devsecops-test/pull/28',NULL);
INSERT INTO findings VALUES(41,6,'RV',unistr('\\n--- RED_TEAM_POC (SUCCESS: False) ---\\n  File "/app/poc_exploit.py", line 1\u000a    ```python\u000a    ^\u000aSyntaxError: invalid syntax\u000a\\n'),'Gitleaks','stripe-access-token','not_secure.py',8,'Found a Stripe Access Token, posing a risk to payment processing services and sensitive financial data.',unistr('import subprocess\u000aimport base64\u000aimport pickle\u000afrom fastapi import FastAPI, Request\u000afrom cryptography.fernet import Fernet\u000a\u000aapp = FastAPI()\u000a\u000aAWS_SECRET_KEY = "AKIAIMNO78987SAMPLEKEY/bXU8JEIKN89098"\u000aSTRIPE_API_KEY = "sk_test_4eC39HqLyjWDarjtT1zdp7dc"\u000a'),'TP',NULL,NULL,5.0,'Medium',unistr('import os\u000afrom fastapi import FastAPI, Request\u000afrom cryptography.fernet import Fernet\u000a\u000aapp = FastAPI()\u000a\u000a# Retrieve secrets from environment variables instead of hard‑coding them in source code.\u000aAWS_SECRET_KEY: str | None = os.getenv("AWS_SECRET_KEY")\u000aSTRIPE_API_KEY: str | None = os.getenv("STRIPE_API_KEY")\u000a\u000a# Ensure the required secrets are available at runtime; otherwise raise an explicit error.\u000aif not AWS_SECRET_KEY or not STRIPE_API_KEY:\u000a    raise RuntimeError(\u000a        "Missing required environment variables for secrets. "\u000a        "Set AWS_SECRET_KEY and STRIPE_API_KEY before starting the service."\u000a    )\u000a\u000a# Example endpoint – replace with real business logic as needed.\u000a@app.get("/")\u000aasync def read_root() -> dict:\u000a    """\u000a    A minimal, secure route that demonstrates the API is running.\u000a    The actual application should use the secrets above in a safe manner\u000a    (e.g., via the Stripe SDK or AWS SDK) rather than exposing them directly.\u000a    """\u000a    return {"message": "Secure API"}'),0,unistr('  File "/app/poc_exploit.py", line 1\u000a    ```python\u000a    ^\u000aSyntaxError: invalid syntax\u000a'),'https://github.com/AnaaaKareem/devsecops-test/pull/28',NULL);
CREATE TABLE pipeline_metrics (
	id INTEGER NOT NULL, 
	scan_id INTEGER, 
	build_duration_seconds FLOAT, 
	artifact_size_bytes INTEGER, 
	num_changed_files INTEGER, 
	test_coverage_percent FLOAT, 
	timestamp DATETIME, 
	PRIMARY KEY (id), 
	FOREIGN KEY(scan_id) REFERENCES scans (id)
);
INSERT INTO pipeline_metrics VALUES(1,5,120.0,55000000,3,85.0,'2025-12-27 10:03:00.437109');
CREATE TABLE feedbacks (
	id INTEGER NOT NULL, 
	finding_id INTEGER, 
	user_verdict VARCHAR, 
	comments TEXT, 
	timestamp DATETIME, 
	PRIMARY KEY (id), 
	FOREIGN KEY(finding_id) REFERENCES findings (id)
);
CREATE INDEX ix_scans_commit_sha ON scans (commit_sha);
CREATE INDEX ix_scans_id ON scans (id);
CREATE INDEX ix_scans_project_name ON scans (project_name);
CREATE INDEX ix_findings_id ON findings (id);
CREATE INDEX ix_pipeline_metrics_id ON pipeline_metrics (id);
CREATE INDEX ix_feedbacks_id ON feedbacks (id);
COMMIT;
