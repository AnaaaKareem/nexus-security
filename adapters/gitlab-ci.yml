stages:
  - fast-scan
  - gate
  - triage
  - quality-audit

# 1. Run all fast tools in parallel
# 1. Zip & Upload to AI Agent (Server-Side Scan)
offload-scan:
  stage: fast-scan
  image: ubuntu:latest
  before_script:
    - apt-get update && apt-get install -y zip curl
  script:
    # 0. Prepare
    # App is assumed running on AI_BRAIN_URL

    # 1. Zip
    - zip -r source_code.zip . -x ".git/*"

    # 2. Upload
    - |
      echo "üöÄ Uploading source code to AI Agent..."
      curl -s -X POST $AI_BRAIN_URL/scan/upload \
        -H "X-API-Key: $AI_API_KEY" \
        -F "project=$CI_PROJECT_PATH" \
        -F "branch=$CI_COMMIT_REF_NAME" \
        -F "commit_sha=$CI_COMMIT_SHA" \
        -F "ci_provider=gitlab-ci" \
        -F "repo_url=$CI_PROJECT_URL" \
        -F "run_url=$CI_JOB_URL" \
        -F "file=@source_code.zip" > scan_response.json

    - cat scan_response.json

  artifacts:
    paths: [scan_response.json]

# 2. Security Gate (Polls for completion)
security-gate:
  stage: gate
  image: alpine:latest
  before_script:
    - apk add --no-cache curl jq
  script:
    - echo "üîç Starting Security Gate..."
    - SCAN_ID=$(cat scan_response.json | jq -r '.scan_id')
    - echo "Monitoring Scan ID $SCAN_ID"
    
    - STATUS="pending"
    - LAST_STATUS=""
    
    # Poll indefinitely until completion
    - |
      while [[ "$STATUS" == "pending" || "$STATUS" == "processing" || "$STATUS" == "uploaded" || "$STATUS" == "scanning" || "$STATUS" == "analyzing" ]]; do
        sleep 10
        RESPONSE=$(curl -s -X GET $AI_BRAIN_URL/scan_status/$SCAN_ID -H "X-API-Key: $AI_API_KEY")
        STATUS=$(echo $RESPONSE | jq -r '.status')
        
        if [[ "$STATUS" != "$LAST_STATUS" ]]; then
          echo "Current Status: $STATUS"
          LAST_STATUS="$STATUS"
        fi
      done

    - |
      if [[ "$STATUS" != "completed" ]]; then
        echo "‚ùå Scan Failed or Timed Out!"
        exit 1
      fi
      
      echo "‚úÖ Security Gate Passed."
      
      # 3. Check for Blocking Issues (Optional)
      RISK_SCORE=$(echo $RESPONSE | jq -r '.risk_score')
      echo "Final Risk Score: $RISK_SCORE"
  dependencies:
    - offload-scan

# 3. SonarQube runs independently
sonarqube-check:
  stage: quality-audit
  script:
    - docker run --rm -e SONAR_HOST_URL=$SONAR_HOST_URL -v "$PWD:/usr/src" sonarsource/sonar-scanner-cli
  allow_failure: true # Doesn't block the AI's work
